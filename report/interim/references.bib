
@misc{noauthor_verified_nodate,
  title   = {Verified efficient parsing for binary data formats — {EverParse} {Manual} documentation},
  url     = {https://project-everest.github.io/everparse/},
  urldate = {2024-01-25}
}

@misc{noauthor_hacl-starhacl-star_2024,
  title     = {hacl-star/hacl-star},
  copyright = {Apache-2.0},
  url       = {https://github.com/hacl-star/hacl-star},
  abstract  = {HACL*, a formally verified cryptographic library written in F*},
  urldate   = {2024-01-25},
  publisher = {hacl-star},
  month     = jan,
  year      = {2024},
  note      = {original-date: 2016-06-23T12:37:16Z},
  keywords  = {cryptography, everest, formal-methods, formal-verification, hacl, high-performance, inria, security, verification, verified-primitives}
}

@article{protzenko_low_2017,
  title    = {Low*:  {Verified} {Low}-{Level} {Programming} {Embedded} in {F}*},
  volume   = {1},
  issn     = {2475-1421},
  url      = {http://arxiv.org/abs/1703.00053},
  doi      = {10.1145/3110261},
  abstract = {We present Low*, a language for low-level programming and verification, and its application to high-assurance optimized cryptographic libraries. Low* is a shallow embedding of a small, sequential, well-behaved subset of C in F*, a dependently-typed variant of ML aimed at program verification. Departing from ML, Low* does not involve any garbage collection or implicit heap allocation; instead, it has a structured memory model {\textbackslash}`a la CompCert, and it provides the control required for writing efficient low-level security-critical code. By virtue of typing, any Low* program is memory safe. In addition, the programmer can make full use of the verification power of F* to write high-level specifications and verify the functional correctness of Low* code using a combination of SMT automation and sophisticated manual proofs. At extraction time, specifications and proofs are erased, and the remaining code enjoys a predictable translation to C. We prove that this translation preserves semantics and side-channel resistance. We provide a new compiler back-end from Low* to C and, to evaluate our approach, we implement and verify various cryptographic algorithms, constructions, and tools for a total of about 28,000 lines of code, specification and proof. We show that our Low* code delivers performance competitive with existing (unverified) C cryptographic libraries, suggesting our approach may be applicable to larger-scale low-level software.},
  number   = {ICFP},
  urldate  = {2024-01-24},
  journal  = {Proceedings of the ACM on Programming Languages},
  author   = {Protzenko, Jonathan and Zinzindohoué, Jean-Karim and Rastogi, Aseem and Ramananandro, Tahina and Wang, Peng and Zanella-Béguelin, Santiago and Delignat-Lavaud, Antoine and Hritcu, Catalin and Bhargavan, Karthikeyan and Fournet, Cédric and Swamy, Nikhil},
  month    = aug,
  year     = {2017},
  note     = {arXiv:1703.00053 [cs]},
  keywords = {Computer Science - Cryptography and Security, Computer Science - Programming Languages},
  pages    = {1--29}
}

@misc{noauthor_magmidemagmide_2024,
  title     = {magmide/magmide},
  url       = {https://github.com/magmide/magmide},
  abstract  = {A dependently-typed proof language intended to make provably correct bare metal code possible for working software engineers.},
  urldate   = {2024-01-25},
  publisher = {magmide},
  month     = jan,
  year      = {2024},
  note      = {original-date: 2020-08-21T23:47:21Z},
  keywords  = {coq, dependent-types, formal-methods, formal-verification, logic, systems-programming, type-safety, verification}
}

@misc{ullrich_electrolysis_nodate,
  title   = {Electrolysis {Coverage}},
  url     = {https://kha.github.io/electrolysis/},
  urldate = {2024-01-25},
  author  = {Ullrich, Sebastian}
}

@misc{xi_applied_2017,
  title      = {Applied {Type} {System}: {An} {Approach} to {Practical} {Programming} with {Theorem}-{Proving}},
  shorttitle = {Applied {Type} {System}},
  url        = {http://arxiv.org/abs/1703.08683},
  doi        = {10.48550/arXiv.1703.08683},
  abstract   = {The framework Pure Type System (PTS) offers a simple and general approach to designing and formalizing type systems. However, in the presence of dependent types, there often exist certain acute problems that make it difficult for PTS to directly accommodate many common realistic programming features such as general recursion, recursive types, effects (e.g., exceptions, references, input/output), etc. In this paper, Applied Type System (ATS) is presented as a framework for designing and formalizing type systems in support of practical programming with advanced types (including dependent types). In particular, it is demonstrated that ATS can readily accommodate a paradigm referred to as programming with theorem-proving (PwTP) in which programs and proofs are constructed in a syntactically intertwined manner, yielding a practical approach to internalizing constraint-solving needed during type-checking. The key salient feature of ATS lies in a complete separation between statics, where types are formed and reasoned about, and dynamics, where programs are constructed and evaluated. With this separation, it is no longer possible for a program to occur in a type as is otherwise allowed in PTS. The paper contains not only a formal development of ATS but also some examples taken from ats-lang.org, a programming language with a type system rooted in ATS, in support of employing ATS as a framework to formulate advanced type systems for practical programming.},
  urldate    = {2024-01-24},
  publisher  = {arXiv},
  author     = {Xi, Hongwei},
  month      = mar,
  year       = {2017},
  note       = {arXiv:1703.08683 [cs]},
  keywords   = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages}
}

@misc{noauthor_ats-home_nodate,
  title   = {{ATS}-{Home}},
  url     = {https://www.cs.bu.edu/~hwxi/atslangweb/Home.html},
  urldate = {2024-01-24}
}

@misc{noauthor_ats-implements_nodate,
  title   = {{ATS}-{Implements}},
  url     = {https://www.cs.bu.edu/~hwxi/atslangweb/Implements.html},
  urldate = {2024-01-24}
}

@misc{ullrich_khaelectrolysis_2024,
  title    = {Kha/electrolysis},
  url      = {https://github.com/Kha/electrolysis},
  abstract = {Simple verification of Rust programs via functional purification in Lean 2(!)},
  urldate  = {2024-01-24},
  author   = {Ullrich, Sebastian},
  month    = jan,
  year     = {2024},
  note     = {original-date: 2016-03-15T20:31:53Z}
}

@article{aeneas,
  title      = {Aeneas: {Rust} {Verification} by {Functional} {Translation}},
  volume     = {6},
  issn       = {2475-1421},
  shorttitle = {Aeneas},
  url        = {http://arxiv.org/abs/2206.07185},
  doi        = {10.1145/3547647},
  abstract   = {We present Aeneas, a new verification toolchain for Rust programs based on a lightweight functional translation. We leverage Rust's rich region-based type system to eliminate memory reasoning for many Rust programs, as long as they do not rely on interior mutability or unsafe code. Doing so, we relieve the proof engineer of the burden of memory-based reasoning, allowing them to instead focus on functional properties of their code. Our first contribution is a new approach to borrows and controlled aliasing. We propose a pure, functional semantics for LLBC, a Low-Level Borrow Calculus that captures a large subset of Rust programs. Our semantics is value-based, meaning there is no notion of memory, addresses or pointer arithmetic. Our semantics is also ownership-centric, meaning that we enforce soundness of borrows via a semantic criterion based on loans rather than through a syntactic type-based lifetime discipline. We claim that our semantics captures the essence of the borrow mechanism rather than its current implementation in the Rust compiler. Our second contribution is a translation from LLBC to a pure lambda-calculus. This allows the user to reason about the original Rust program through the theorem prover of their choice. To deal with the well-known technical difficulty of terminating a borrow, we rely on a novel approach, in which we approximate the borrow graph in the presence of function calls. This in turn allows us to perform the translation using a new technical device called backward functions. We implement our toolchain in a mixture of Rust and OCaml. Our evaluation shows significant gains of verification productivity for the programmer. Rust goes to great lengths to enforce static control of aliasing; the proof engineer should not waste any time on memory reasoning when so much already comes "for free"!},
  number     = {ICFP},
  urldate    = {2024-01-24},
  journal    = {Proceedings of the ACM on Programming Languages},
  author     = {Ho, Son and Protzenko, Jonathan},
  month      = aug,
  year       = {2022},
  note       = {arXiv:2206.07185 [cs]},
  keywords   = {Computer Science - Programming Languages},
  pages      = {711--741}
}

@article{pierre-evariste_transporting_2014,
  title    = {Transporting {Functions} across {Ornaments}},
  volume   = {24},
  issn     = {0956-7968, 1469-7653},
  url      = {http://arxiv.org/abs/1201.4801},
  doi      = {10.1017/S0956796814000069},
  abstract = {Programming with dependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the definition of data-types: we can finally write correct-by-construction software. However, this extreme accuracy is also a curse: a data-type is the combination of a structuring medium together with a special purpose logic. These domain-specific logics hamper any effort of code reuse among similarly structured data. In this paper, we exorcise our data-types by adapting the notion of ornament to our universe of inductive families. We then show how code reuse can be achieved by ornamenting functions. Using these functional ornament, we capture the relationship between functions such as the addition of natural numbers and the concatenation of lists. With this knowledge, we demonstrate how the implementation of the former informs the implementation of the latter: the user can ask the definition of addition to be lifted to lists and she will only be asked the details necessary to carry on adding lists rather than numbers. Our presentation is formalised in a type theory with a universe of data-types and all our constructions have been implemented as generic programs, requiring no extension to the type theory.},
  number   = {2-3},
  urldate  = {2024-01-24},
  journal  = {Journal of Functional Programming},
  author   = {Pierre-Evariste, Dagand and Conor, McBride},
  month    = may,
  year     = {2014},
  note     = {arXiv:1201.4801 [cs]},
  keywords = {Computer Science - Programming Languages},
  pages    = {316--383}
}

@article{jacobs_dijkstra_2015,
  series   = {Coalgebraic {Methods} in {Computer} {Science}},
  title    = {Dijkstra and {Hoare} monads in monadic computation},
  volume   = {604},
  issn     = {0304-3975},
  url      = {https://www.sciencedirect.com/science/article/pii/S0304397515002364},
  doi      = {10.1016/j.tcs.2015.03.020},
  abstract = {The Dijkstra and Hoare monads have been introduced recently for capturing weakest precondition computations and computations with pre- and post-conditions, within the context of program verification, supported by a theorem prover. Here we give a more general description of such monads in a categorical setting. We first elaborate the recently developed view on program semantics in terms of a triangle of computations, state transformers, and predicate transformers. Instantiating this triangle for different computational monads T shows how to define the Dijkstra monad associated with T, via the logic involved. Subsequently we give abstract definitions of the Dijkstra and Hoare monad, parametrised by a computational monad. These definitions presuppose a suitable (categorical) predicate logic, defined on the Kleisli category of the underlying monad. When all this structure exists, we show that there are maps of monads (Hoare) ⇒ (State) ⇒ (Dijkstra), all parametrised by a monad T.},
  urldate  = {2024-01-24},
  journal  = {Theoretical Computer Science},
  author   = {Jacobs, Bart},
  month    = nov,
  year     = {2015},
  keywords = {Hoare logic, Monad, Program semantics, Weakest precondition},
  pages    = {30--45}
}

@misc{noauthor_dijkstra_nodate,
  title   = {Dijkstra and {Hoare} monads in monadic computation - {ScienceDirect}},
  url     = {https://www.sciencedirect.com/science/article/pii/S0304397515002364},
  urldate = {2024-01-24}
}

@inproceedings{swamy_verifying_2013,
  title    = {Verifying {Higher}-order {Programs} with the {Dijkstra} {Monad}},
  url      = {https://www.microsoft.com/en-us/research/publication/verifying-higher-order-programs-with-the-dijkstra-monad/},
  abstract = {Modern programming languages, ranging from Haskell and ML, to JavaScript, C\# and Java, all make extensive use of higher-order state. This paper advocates a new verification methodology for higher-order stateful programs, based on a new monad of predicate transformers called the Dijkstra monad. Using the Dijkstra monad has a number of benefits. First, the monad […]},
  language = {en-US},
  urldate  = {2024-01-24},
  author   = {Swamy, Nikhil and Chen, Juan and Livshits, Ben},
  month    = jun,
  year     = {2013}
}

@inproceedings{nanevski_under_nodate,
  title    = {Under {Consideration} for {Publication} in {J}. {Functional} {Programming} {Hoare} {Type} {Theory}, {Polymorphism} and {Separation}},
  url      = {https://www.semanticscholar.org/paper/Under-Consideration-for-Publication-in-J.-Hoare-and-Nanevski-Morrisett/aef3d1fc100d0ed4561549da30f002bf9ee21722},
  abstract = {We consider the problem of reconciling a dependently typed functional language with imperative features such as mutable higher-order state, pointer aliasing, and non-termination. We propose Hoare Type Theory (HTT), which incorporates Hoare-style specifications into types, making it possible to statically track and enforce correct use of side effects. The main feature of HTT is the Hoare type \{P \}x:A\{Q\} specifying computations with precondition P and postcondition Q that return a result of type A. Hoare types can be nested, combined with other types, and abstracted, leading to a smooth integration with higher-order functions and type polymorphism. We further show that in the presence of type polymorphism, it becomes possible to interpret the Hoare types in the " small footprint " manner, as advocated by Separation Logic, whereby specifications tightly describe the state required by the computation. We establish that HTT is sound and compositional, in the sense that separate verifica-tions of individual program components suffice to ensure the correctness of the composite program.},
  urldate  = {2024-01-24},
  author   = {Nanevski, Aleksandar and Morrisett, Greg and Birkedal, L.}
}

@misc{ahman_dijkstra_2019,
  title     = {Dijkstra {Monads} for {Free}},
  url       = {http://arxiv.org/abs/1608.06499},
  doi       = {10.48550/arXiv.1608.06499},
  abstract  = {Dijkstra monads enable a dependent type theory to be enhanced with support for specifying and verifying effectful code via weakest preconditions. Together with their closely related counterparts, Hoare monads, they provide the basis on which verification tools like F*, Hoare Type Theory (HTT), and Ynot are built. We show that Dijkstra monads can be derived "for free" by applying a continuation-passing style (CPS) translation to the standard monadic definitions of the underlying computational effects. Automatically deriving Dijkstra monads in this way provides a correct-by-construction and efficient way of reasoning about user-defined effects in dependent type theories. We demonstrate these ideas in EMF*, a new dependently typed calculus, validating it via both formal proof and a prototype implementation within F*. Besides equipping F* with a more uniform and extensible effect system, EMF* enables a novel mixture of intrinsic and extrinsic proofs within F*.},
  urldate   = {2024-01-24},
  publisher = {arXiv},
  author    = {Ahman, Danel and Hritcu, Catalin and Maillard, Kenji and Martinez, Guido and Plotkin, Gordon and Protzenko, Jonathan and Rastogi, Aseem and Swamy, Nikhil},
  month     = oct,
  year      = {2019},
  note      = {arXiv:1608.06499 [cs]},
  keywords  = {Computer Science - Programming Languages}
}

@article{nanevski_ynot_2008,
  title      = {Ynot: dependent types for imperative programs},
  volume     = {43},
  issn       = {0362-1340},
  shorttitle = {Ynot},
  url        = {https://doi.org/10.1145/1411203.1411237},
  doi        = {10.1145/1411203.1411237},
  abstract   = {We describe an axiomatic extension to the Coq proof assistant, that supports writing, reasoning about, and extracting higher-order, dependently-typed programs with side-effects. Coq already includes a powerful functional language that supports dependent types, but that language is limited to pure, total functions. The key contribution of our extension, which we call Ynot, is the added support for computations that may have effects such as non-termination, accessing a mutable store, and throwing/catching exceptions. The axioms of Ynot form a small trusted computing base which has been formally justified in our previous work on Hoare Type Theory (HTT). We show how these axioms can be combined with the powerful type and abstraction mechanisms of Coq to build higher-level reasoning mechanisms which in turn can be used to build realistic, verified software components. To substantiate this claim, we describe here a representative series of modules that implement imperative finite maps, including support for a higher-order (effectful) iterator. The implementations range from simple (e.g., association lists) to complex (e.g., hash tables) but share a common interface which abstracts the implementation details and ensures that the modules properly implement the finite map abstraction.},
  number     = {9},
  urldate    = {2024-01-24},
  journal    = {ACM SIGPLAN Notices},
  author     = {Nanevski, Aleksandar and Morrisett, Greg and Shinnar, Avraham and Govereau, Paul and Birkedal, Lars},
  month      = sep,
  year       = {2008},
  keywords   = {Hoare logic, monads, separation logic, type theory},
  pages      = {229--240}
}

@inproceedings{chen_combining_2005,
  address   = {New York, NY, USA},
  series    = {{ICFP} '05},
  title     = {Combining programming with theorem proving},
  isbn      = {9781595930644},
  url       = {https://doi.org/10.1145/1086365.1086375},
  doi       = {10.1145/1086365.1086375},
  abstract  = {Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming. In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable. To support practical programming, we adopted a design in the past that imposes certain restrictions on the syntactic form of constraints so that some effective means can be found for solving constraints automatically. Evidently, this is a rather em ad hoc design in its nature. In this design, which we claim to be both novel and practical. Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints. In particular, we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving. Also we present some concrete examples in support of the practicality of this design.},
  urldate   = {2024-01-24},
  booktitle = {Proceedings of the tenth {ACM} {SIGPLAN} international conference on {Functional} programming},
  publisher = {Association for Computing Machinery},
  author    = {Chen, Chiyan and Xi, Hongwei},
  month     = sep,
  year      = {2005},
  keywords  = {ATS, applied type system, dependent types, proof erasure, theorem proving},
  pages     = {66--77}
}

@inproceedings{xi_imperative_2000,
  title     = {Imperative programming with dependent types},
  url       = {https://ieeexplore.ieee.org/document/855785},
  doi       = {10.1109/LICS.2000.855785},
  abstract  = {The article enriches imperative programming with a form of dependent types. We start by explaining some motivations for this enrichment and mentioning some major obstacles that need to be overcome. We then present the design of a source level dependently typed imperative programming language Xanadu, forming both static and dynamic semantics and then establishing the type soundness theorem. We also present realistic examples, which have all been verified in a prototype implementation, in support of the practicality of Xanadu. We claim that the language design of Xanadu is novel and it serves as an informative example that demonstrates a means to combine imperative programming with dependent types.},
  urldate   = {2024-01-24},
  booktitle = {Proceedings {Fifteenth} {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science} ({Cat}. {No}.{99CB36332})},
  author    = {Xi, Hongwei},
  month     = jun,
  year      = {2000},
  note      = {ISSN: 1043-6871},
  keywords  = {Assembly, Computer languages, Dynamic programming, Functional programming, Natural languages, Pattern matching, Programming profession, Proposals, Prototypes, Runtime},
  pages     = {375--387}
}


@inproceedings{klein_sel4_2009,
  address    = {Big Sky Montana USA},
  title      = {{seL4}: formal verification of an {OS} kernel},
  isbn       = {9781605587523},
  shorttitle = {{seL4}},
  url        = {https://dl.acm.org/doi/10.1145/1629575.1629596},
  doi        = {10.1145/1629575.1629596},
  language   = {en},
  urldate    = {2024-01-25},
  booktitle  = {Proceedings of the {ACM} {SIGOPS} 22nd symposium on {Operating} systems principles},
  publisher  = {ACM},
  author     = {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal and Norrish, Michael and Sewell, Thomas and Tuch, Harvey and Winwood, Simon},
  month      = oct,
  year       = {2009},
  pages      = {207--220}
}



@article{jung_rustbelt_2018,
  title      = {{RustBelt}: securing the foundations of the {Rust} programming language},
  volume     = {2},
  issn       = {2475-1421},
  shorttitle = {{RustBelt}},
  url        = {https://dl.acm.org/doi/10.1145/3158154},
  doi        = {10.1145/3158154},
  abstract   = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
  language   = {en},
  number     = {POPL},
  urldate    = {2024-01-25},
  journal    = {Proceedings of the ACM on Programming Languages},
  author     = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  month      = jan,
  year       = {2018},
  pages      = {1--34}
}



@misc{noauthor_iris_nodate,
  title   = {Iris {Project}},
  url     = {https://iris-project.org/},
  urldate = {2024-01-25}
}

