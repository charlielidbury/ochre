@article{aeneas,
  title = {Aeneas: {{Rust Verification}} by {{Functional Translation}}},
  shorttitle = {Aeneas},
  author = {Ho, Son and Protzenko, Jonathan},
  year = {2022},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {ICFP},
  eprint = {2206.07185},
  primaryclass = {cs},
  pages = {711--741},
  issn = {2475-1421},
  doi = {10.1145/3547647},
  urldate = {2024-01-24},
  abstract = {We present Aeneas, a new verification toolchain for Rust programs based on a lightweight functional translation. We leverage Rust's rich region-based type system to eliminate memory reasoning for many Rust programs, as long as they do not rely on interior mutability or unsafe code. Doing so, we relieve the proof engineer of the burden of memory-based reasoning, allowing them to instead focus on functional properties of their code. Our first contribution is a new approach to borrows and controlled aliasing. We propose a pure, functional semantics for LLBC, a Low-Level Borrow Calculus that captures a large subset of Rust programs. Our semantics is value-based, meaning there is no notion of memory, addresses or pointer arithmetic. Our semantics is also ownership-centric, meaning that we enforce soundness of borrows via a semantic criterion based on loans rather than through a syntactic type-based lifetime discipline. We claim that our semantics captures the essence of the borrow mechanism rather than its current implementation in the Rust compiler. Our second contribution is a translation from LLBC to a pure lambda-calculus. This allows the user to reason about the original Rust program through the theorem prover of their choice. To deal with the well-known technical difficulty of terminating a borrow, we rely on a novel approach, in which we approximate the borrow graph in the presence of function calls. This in turn allows us to perform the translation using a new technical device called backward functions. We implement our toolchain in a mixture of Rust and OCaml. Our evaluation shows significant gains of verification productivity for the programmer. Rust goes to great lengths to enforce static control of aliasing; the proof engineer should not waste any time on memory reasoning when so much already comes "for free"!},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/EWDQJVU3/Ho and Protzenko - 2022 - Aeneas Rust Verification by Functional Translatio.pdf;/Users/charlielidbury/Zotero/storage/DQQKHDX8/Ho and Protzenko - 2022 - Aeneas Rust Verification by Functional Translatio.html}
}

@misc{ahmanDijkstraMonadsFree2019,
  title = {Dijkstra {{Monads}} for {{Free}}},
  author = {Ahman, Danel and Hritcu, Catalin and Maillard, Kenji and Martinez, Guido and Plotkin, Gordon and Protzenko, Jonathan and Rastogi, Aseem and Swamy, Nikhil},
  year = {2019},
  month = oct,
  number = {arXiv:1608.06499},
  eprint = {1608.06499},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.1608.06499},
  urldate = {2024-01-24},
  abstract = {Dijkstra monads enable a dependent type theory to be enhanced with support for specifying and verifying effectful code via weakest preconditions. Together with their closely related counterparts, Hoare monads, they provide the basis on which verification tools like F*, Hoare Type Theory (HTT), and Ynot are built. We show that Dijkstra monads can be derived "for free" by applying a continuation-passing style (CPS) translation to the standard monadic definitions of the underlying computational effects. Automatically deriving Dijkstra monads in this way provides a correct-by-construction and efficient way of reasoning about user-defined effects in dependent type theories. We demonstrate these ideas in EMF*, a new dependently typed calculus, validating it via both formal proof and a prototype implementation within F*. Besides equipping F* with a more uniform and extensible effect system, EMF* enables a novel mixture of intrinsic and extrinsic proofs within F*.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  note = {Comment: extended pre-print for POPL 2017 final version with the missing ERC acknowledgement},
  file = {/Users/charlielidbury/Zotero/storage/PPWMR49X/Ahman et al. - 2019 - Dijkstra Monads for Free.pdf;/Users/charlielidbury/Zotero/storage/HB3ZZQ8W/Ahman et al. - 2019 - Dijkstra Monads for Free.html}
}

@misc{ATSHome,
  title = {{{ATS-Home}}},
  urldate = {2024-01-24},
  howpublished = {https://www.cs.bu.edu/{\textasciitilde}hwxi/atslangweb/Home.html}
}

@misc{ATSImplements,
  title = {{{ATS-Implements}}},
  urldate = {2024-01-24},
  howpublished = {https://www.cs.bu.edu/{\textasciitilde}hwxi/atslangweb/Implements.html}
}

@inproceedings{chenCombiningProgrammingTheorem2005,
  title = {Combining Programming with Theorem Proving},
  booktitle = {Proceedings of the Tenth {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Chen, Chiyan and Xi, Hongwei},
  year = {2005},
  month = sep,
  series = {{{ICFP}} '05},
  pages = {66--77},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1086365.1086375},
  urldate = {2024-01-24},
  abstract = {Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming. In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable. To support practical programming, we adopted a design in the past that imposes certain restrictions on the syntactic form of constraints so that some effective means can be found for solving constraints automatically. Evidently, this is a rather em ad hoc design in its nature. In this design, which we claim to be both novel and practical. Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints. In particular, we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving. Also we present some concrete examples in support of the practicality of this design.},
  isbn = {978-1-59593-064-4},
  keywords = {applied type system,ATS,dependent types,proof erasure,theorem proving}
}

@misc{DijkstraHoareMonads,
  title = {Dijkstra and {{Hoare}} Monads in Monadic Computation - {{ScienceDirect}}},
  urldate = {2024-01-24},
  howpublished = {https://www.sciencedirect.com/science/article/pii/S0304397515002364}
}

@article{jacobsDijkstraHoareMonads2015,
  title = {Dijkstra and {{Hoare}} Monads in Monadic Computation},
  author = {Jacobs, Bart},
  year = {2015},
  month = nov,
  journal = {Theoretical Computer Science},
  series = {Coalgebraic {{Methods}} in {{Computer Science}}},
  volume = {604},
  pages = {30--45},
  issn = {0304-3975},
  doi = {10.1016/j.tcs.2015.03.020},
  urldate = {2024-01-24},
  abstract = {The Dijkstra and Hoare monads have been introduced recently for capturing weakest precondition computations and computations with pre- and post-conditions, within the context of program verification, supported by a theorem prover. Here we give a more general description of such monads in a categorical setting. We first elaborate the recently developed view on program semantics in terms of a triangle of computations, state transformers, and predicate transformers. Instantiating this triangle for different computational monads T shows how to define the Dijkstra monad associated with T, via the logic involved. Subsequently we give abstract definitions of the Dijkstra and Hoare monad, parametrised by a computational monad. These definitions presuppose a suitable (categorical) predicate logic, defined on the Kleisli category of the underlying monad. When all this structure exists, we show that there are maps of monads (Hoare) {$\Rightarrow$} (State) {$\Rightarrow$} (Dijkstra), all parametrised by a monad T.},
  keywords = {Hoare logic,Monad,Program semantics,Weakest precondition},
  file = {/Users/charlielidbury/Zotero/storage/3KN8RQJV/Jacobs - 2015 - Dijkstra and Hoare monads in monadic computation.html}
}

@inproceedings{nanevskiConsiderationPublicationFunctional,
  title = {Under {{Consideration}} for {{Publication}} in {{J}}. {{Functional Programming Hoare Type Theory}}, {{Polymorphism}} and {{Separation}}},
  author = {Nanevski, Aleksandar and Morrisett, Greg and Birkedal, L.},
  urldate = {2024-01-24},
  abstract = {We consider the problem of reconciling a dependently typed functional language with imperative features such as mutable higher-order state, pointer aliasing, and non-termination. We propose Hoare Type Theory (HTT), which incorporates Hoare-style specifications into types, making it possible to statically track and enforce correct use of side effects. The main feature of HTT is the Hoare type \{P \}x:A\{Q\} specifying computations with precondition P and postcondition Q that return a result of type A. Hoare types can be nested, combined with other types, and abstracted, leading to a smooth integration with higher-order functions and type polymorphism. We further show that in the presence of type polymorphism, it becomes possible to interpret the Hoare types in the " small footprint " manner, as advocated by Separation Logic, whereby specifications tightly describe the state required by the computation. We establish that HTT is sound and compositional, in the sense that separate verifica-tions of individual program components suffice to ensure the correctness of the composite program.},
  note = {[TLDR] This work considers the problem of reconciling a dependently typed functional language with imperative features such as mutable higher-order state, pointer aliasing, and non-termination, and proposes Hoare Type Theory (HTT), which incorporates Hoare-style specifications into types, making it possible to statically track and enforce correct use of side effects.}
}

@article{nanevskiYnotDependentTypes2008,
  title = {Ynot: Dependent Types for Imperative Programs},
  shorttitle = {Ynot},
  author = {Nanevski, Aleksandar and Morrisett, Greg and Shinnar, Avraham and Govereau, Paul and Birkedal, Lars},
  year = {2008},
  month = sep,
  journal = {ACM SIGPLAN Notices},
  volume = {43},
  number = {9},
  pages = {229--240},
  issn = {0362-1340},
  doi = {10.1145/1411203.1411237},
  urldate = {2024-01-24},
  abstract = {We describe an axiomatic extension to the Coq proof assistant, that supports writing, reasoning about, and extracting higher-order, dependently-typed programs with side-effects. Coq already includes a powerful functional language that supports dependent types, but that language is limited to pure, total functions. The key contribution of our extension, which we call Ynot, is the added support for computations that may have effects such as non-termination, accessing a mutable store, and throwing/catching exceptions. The axioms of Ynot form a small trusted computing base which has been formally justified in our previous work on Hoare Type Theory (HTT). We show how these axioms can be combined with the powerful type and abstraction mechanisms of Coq to build higher-level reasoning mechanisms which in turn can be used to build realistic, verified software components. To substantiate this claim, we describe here a representative series of modules that implement imperative finite maps, including support for a higher-order (effectful) iterator. The implementations range from simple (e.g., association lists) to complex (e.g., hash tables) but share a common interface which abstracts the implementation details and ensures that the modules properly implement the finite map abstraction.},
  keywords = {Hoare logic,monads,separation logic,type theory}
}

@article{pierre-evaristeTransportingFunctionsOrnaments2014,
  title = {Transporting {{Functions}} across {{Ornaments}}},
  author = {{Pierre-Evariste}, Dagand and Conor, McBride},
  year = {2014},
  month = may,
  journal = {Journal of Functional Programming},
  volume = {24},
  number = {2-3},
  eprint = {1201.4801},
  primaryclass = {cs},
  pages = {316--383},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796814000069},
  urldate = {2024-01-24},
  abstract = {Programming with dependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the definition of data-types: we can finally write correct-by-construction software. However, this extreme accuracy is also a curse: a data-type is the combination of a structuring medium together with a special purpose logic. These domain-specific logics hamper any effort of code reuse among similarly structured data. In this paper, we exorcise our data-types by adapting the notion of ornament to our universe of inductive families. We then show how code reuse can be achieved by ornamenting functions. Using these functional ornament, we capture the relationship between functions such as the addition of natural numbers and the concatenation of lists. With this knowledge, we demonstrate how the implementation of the former informs the implementation of the latter: the user can ask the definition of addition to be lifted to lists and she will only be asked the details necessary to carry on adding lists rather than numbers. Our presentation is formalised in a type theory with a universe of data-types and all our constructions have been implemented as generic programs, requiring no extension to the type theory.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/R2829K92/Pierre-Evariste and Conor - 2014 - Transporting Functions across Ornaments.pdf;/Users/charlielidbury/Zotero/storage/HC3TCW8I/Pierre-Evariste and Conor - 2014 - Transporting Functions across Ornaments.html}
}

@article{protzenkoVerifiedLowLevelProgramming2017,
  title = {Verified {{Low-Level Programming Embedded}} in {{F}}*},
  author = {Protzenko, Jonathan and Zinzindohou{\'e}, Jean-Karim and Rastogi, Aseem and Ramananandro, Tahina and Wang, Peng and {Zanella-B{\'e}guelin}, Santiago and {Delignat-Lavaud}, Antoine and Hritcu, Catalin and Bhargavan, Karthikeyan and Fournet, C{\'e}dric and Swamy, Nikhil},
  year = {2017},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {1},
  number = {ICFP},
  eprint = {1703.00053},
  primaryclass = {cs},
  pages = {1--29},
  issn = {2475-1421},
  doi = {10.1145/3110261},
  urldate = {2024-01-24},
  abstract = {We present Low*, a language for low-level programming and verification, and its application to high-assurance optimized cryptographic libraries. Low* is a shallow embedding of a small, sequential, well-behaved subset of C in F*, a dependently-typed variant of ML aimed at program verification. Departing from ML, Low* does not involve any garbage collection or implicit heap allocation; instead, it has a structured memory model {\textbackslash}`a la CompCert, and it provides the control required for writing efficient low-level security-critical code. By virtue of typing, any Low* program is memory safe. In addition, the programmer can make full use of the verification power of F* to write high-level specifications and verify the functional correctness of Low* code using a combination of SMT automation and sophisticated manual proofs. At extraction time, specifications and proofs are erased, and the remaining code enjoys a predictable translation to C. We prove that this translation preserves semantics and side-channel resistance. We provide a new compiler back-end from Low* to C and, to evaluate our approach, we implement and verify various cryptographic algorithms, constructions, and tools for a total of about 28,000 lines of code, specification and proof. We show that our Low* code delivers performance competitive with existing (unverified) C cryptographic libraries, suggesting our approach may be applicable to larger-scale low-level software.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Programming Languages},
  note = {Comment: extended version of ICFP final camera ready version; only Acknowledgements differ from 30 Aug 2017 version},
  file = {/Users/charlielidbury/Zotero/storage/6DNMIKF6/Protzenko et al. - 2017 - Verified Low-Level Programming Embedded in F.pdf;/Users/charlielidbury/Zotero/storage/UTTHN35Q/Protzenko et al. - 2017 - Verified Low-Level Programming Embedded in F.html}
}

@inproceedings{swamyVerifyingHigherorderPrograms2013,
  title = {Verifying {{Higher-order Programs}} with the {{Dijkstra Monad}}},
  booktitle = {{{ACM Programming Language Design}} and {{Implementation}} ({{PLDI}}) 2013},
  author = {Swamy, Nikhil and Chen, Juan and Livshits, Ben},
  year = {2013},
  month = jun,
  urldate = {2024-01-24},
  abstract = {Modern programming languages, ranging from Haskell and ML, to JavaScript, C\# and Java, all make extensive use of higher-order state. This paper advocates a new verification methodology for higher-order stateful programs, based on a new monad of predicate transformers called the Dijkstra monad. Using the Dijkstra monad has a number of benefits. First, the monad [{\dots}]},
  langid = {american},
  file = {/Users/charlielidbury/Zotero/storage/E46BW5N8/Swamy et al. - 2013 - Verifying Higher-order Programs with the Dijkstra .pdf}
}

@misc{ullrichKhaElectrolysis2024,
  title = {Kha/Electrolysis},
  author = {Ullrich, Sebastian},
  year = {2024},
  month = jan,
  urldate = {2024-01-24},
  abstract = {Simple verification of Rust programs via functional purification in Lean 2(!)}
}

@misc{xiAppliedTypeSystem2017,
  title = {Applied {{Type System}}: {{An Approach}} to {{Practical Programming}} with {{Theorem-Proving}}},
  shorttitle = {Applied {{Type System}}},
  author = {Xi, Hongwei},
  year = {2017},
  month = mar,
  number = {arXiv:1703.08683},
  eprint = {1703.08683},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.1703.08683},
  urldate = {2024-01-24},
  abstract = {The framework Pure Type System (PTS) offers a simple and general approach to designing and formalizing type systems. However, in the presence of dependent types, there often exist certain acute problems that make it difficult for PTS to directly accommodate many common realistic programming features such as general recursion, recursive types, effects (e.g., exceptions, references, input/output), etc. In this paper, Applied Type System (ATS) is presented as a framework for designing and formalizing type systems in support of practical programming with advanced types (including dependent types). In particular, it is demonstrated that ATS can readily accommodate a paradigm referred to as programming with theorem-proving (PwTP) in which programs and proofs are constructed in a syntactically intertwined manner, yielding a practical approach to internalizing constraint-solving needed during type-checking. The key salient feature of ATS lies in a complete separation between statics, where types are formed and reasoned about, and dynamics, where programs are constructed and evaluated. With this separation, it is no longer possible for a program to occur in a type as is otherwise allowed in PTS. The paper contains not only a formal development of ATS but also some examples taken from ats-lang.org, a programming language with a type system rooted in ATS, in support of employing ATS as a framework to formulate advanced type systems for practical programming.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/AX5D88SU/Xi - 2017 - Applied Type System An Approach to Practical Prog.pdf;/Users/charlielidbury/Zotero/storage/AVQ38G85/Xi - 2017 - Applied Type System An Approach to Practical Prog.html}
}

@inproceedings{xiImperativeProgrammingDependent2000,
  title = {Imperative Programming with Dependent Types},
  booktitle = {Proceedings {{Fifteenth Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{Cat}}. {{No}}.{{99CB36332}})},
  author = {Xi, Hongwei},
  year = {2000},
  month = jun,
  pages = {375--387},
  issn = {1043-6871},
  doi = {10.1109/LICS.2000.855785},
  urldate = {2024-01-24},
  abstract = {The article enriches imperative programming with a form of dependent types. We start by explaining some motivations for this enrichment and mentioning some major obstacles that need to be overcome. We then present the design of a source level dependently typed imperative programming language Xanadu, forming both static and dynamic semantics and then establishing the type soundness theorem. We also present realistic examples, which have all been verified in a prototype implementation, in support of the practicality of Xanadu. We claim that the language design of Xanadu is novel and it serves as an informative example that demonstrates a means to combine imperative programming with dependent types.},
  keywords = {Assembly,Computer languages,Dynamic programming,Functional programming,Natural languages,Pattern matching,Programming profession,Proposals,Prototypes,Runtime},
  file = {/Users/charlielidbury/Zotero/storage/EBV2WRZB/Xi - 2000 - Imperative programming with dependent types.html}
}
