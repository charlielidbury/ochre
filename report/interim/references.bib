@article{aeneas,
  title = {Aeneas: {{Rust Verification}} by {{Functional Translation}}},
  shorttitle = {Aeneas},
  author = {Ho, Son and Protzenko, Jonathan},
  year = {2022},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {ICFP},
  eprint = {2206.07185},
  primaryclass = {cs},
  pages = {711--741},
  issn = {2475-1421},
  doi = {10.1145/3547647},
  url = {http://arxiv.org/abs/2206.07185},
  urldate = {2024-01-24},
  abstract = {We present Aeneas, a new verification toolchain for Rust programs based on a lightweight functional translation. We leverage Rust's rich region-based type system to eliminate memory reasoning for many Rust programs, as long as they do not rely on interior mutability or unsafe code. Doing so, we relieve the proof engineer of the burden of memory-based reasoning, allowing them to instead focus on functional properties of their code. Our first contribution is a new approach to borrows and controlled aliasing. We propose a pure, functional semantics for LLBC, a Low-Level Borrow Calculus that captures a large subset of Rust programs. Our semantics is value-based, meaning there is no notion of memory, addresses or pointer arithmetic. Our semantics is also ownership-centric, meaning that we enforce soundness of borrows via a semantic criterion based on loans rather than through a syntactic type-based lifetime discipline. We claim that our semantics captures the essence of the borrow mechanism rather than its current implementation in the Rust compiler. Our second contribution is a translation from LLBC to a pure lambda-calculus. This allows the user to reason about the original Rust program through the theorem prover of their choice. To deal with the well-known technical difficulty of terminating a borrow, we rely on a novel approach, in which we approximate the borrow graph in the presence of function calls. This in turn allows us to perform the translation using a new technical device called backward functions. We implement our toolchain in a mixture of Rust and OCaml. Our evaluation shows significant gains of verification productivity for the programmer. Rust goes to great lengths to enforce static control of aliasing; the proof engineer should not waste any time on memory reasoning when so much already comes "for free"!},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/EWDQJVU3/Ho and Protzenko - 2022 - Aeneas Rust Verification by Functional Translatio.pdf;/Users/charlielidbury/Zotero/storage/DQQKHDX8/Ho and Protzenko - 2022 - Aeneas Rust Verification by Functional Translatio.html}
}

@article{aeneas,
  title = {Aeneas: {{Rust Verification}} by {{Functional Translation}}},
  shorttitle = {Aeneas},
  author = {Ho, Son and Protzenko, Jonathan},
  year = {2022},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {ICFP},
  eprint = {2206.07185},
  primaryclass = {cs},
  pages = {711--741},
  issn = {2475-1421},
  doi = {10.1145/3547647},
  url = {http://arxiv.org/abs/2206.07185},
  urldate = {2024-01-24},
  abstract = {We present Aeneas, a new verification toolchain for Rust programs based on a lightweight functional translation. We leverage Rust's rich region-based type system to eliminate memory reasoning for many Rust programs, as long as they do not rely on interior mutability or unsafe code. Doing so, we relieve the proof engineer of the burden of memory-based reasoning, allowing them to instead focus on functional properties of their code. Our first contribution is a new approach to borrows and controlled aliasing. We propose a pure, functional semantics for LLBC, a Low-Level Borrow Calculus that captures a large subset of Rust programs. Our semantics is value-based, meaning there is no notion of memory, addresses or pointer arithmetic. Our semantics is also ownership-centric, meaning that we enforce soundness of borrows via a semantic criterion based on loans rather than through a syntactic type-based lifetime discipline. We claim that our semantics captures the essence of the borrow mechanism rather than its current implementation in the Rust compiler. Our second contribution is a translation from LLBC to a pure lambda-calculus. This allows the user to reason about the original Rust program through the theorem prover of their choice. To deal with the well-known technical difficulty of terminating a borrow, we rely on a novel approach, in which we approximate the borrow graph in the presence of function calls. This in turn allows us to perform the translation using a new technical device called backward functions. We implement our toolchain in a mixture of Rust and OCaml. Our evaluation shows significant gains of verification productivity for the programmer. Rust goes to great lengths to enforce static control of aliasing; the proof engineer should not waste any time on memory reasoning when so much already comes "for free"!},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/4SRHSEQE/Ho and Protzenko - 2022 - Aeneas Rust Verification by Functional Translatio.pdf;/Users/charlielidbury/Zotero/storage/6XH5QBGJ/Ho and Protzenko - 2022 - Aeneas Rust Verification by Functional Translatio.html}
}

@misc{ahmanDijkstraMonadsFree2019,
  title = {Dijkstra {{Monads}} for {{Free}}},
  author = {Ahman, Danel and Hritcu, Catalin and Maillard, Kenji and Martinez, Guido and Plotkin, Gordon and Protzenko, Jonathan and Rastogi, Aseem and Swamy, Nikhil},
  year = {2019},
  month = oct,
  number = {arXiv:1608.06499},
  eprint = {1608.06499},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1608.06499},
  url = {http://arxiv.org/abs/1608.06499},
  urldate = {2024-01-24},
  abstract = {Dijkstra monads enable a dependent type theory to be enhanced with support for specifying and verifying effectful code via weakest preconditions. Together with their closely related counterparts, Hoare monads, they provide the basis on which verification tools like F*, Hoare Type Theory (HTT), and Ynot are built. We show that Dijkstra monads can be derived "for free" by applying a continuation-passing style (CPS) translation to the standard monadic definitions of the underlying computational effects. Automatically deriving Dijkstra monads in this way provides a correct-by-construction and efficient way of reasoning about user-defined effects in dependent type theories. We demonstrate these ideas in EMF*, a new dependently typed calculus, validating it via both formal proof and a prototype implementation within F*. Besides equipping F* with a more uniform and extensible effect system, EMF* enables a novel mixture of intrinsic and extrinsic proofs within F*.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  note = {Comment: extended pre-print for POPL 2017 final version with the missing ERC acknowledgement},
  file = {/Users/charlielidbury/Zotero/storage/PPWMR49X/Ahman et al. - 2019 - Dijkstra Monads for Free.pdf;/Users/charlielidbury/Zotero/storage/HB3ZZQ8W/Ahman et al. - 2019 - Dijkstra Monads for Free.html}
}

@misc{ahmanDijkstraMonadsFree2019,
  title = {Dijkstra {{Monads}} for {{Free}}},
  author = {Ahman, Danel and Hritcu, Catalin and Maillard, Kenji and Martinez, Guido and Plotkin, Gordon and Protzenko, Jonathan and Rastogi, Aseem and Swamy, Nikhil},
  year = {2019},
  month = oct,
  number = {arXiv:1608.06499},
  eprint = {1608.06499},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1608.06499},
  url = {http://arxiv.org/abs/1608.06499},
  urldate = {2024-01-24},
  abstract = {Dijkstra monads enable a dependent type theory to be enhanced with support for specifying and verifying effectful code via weakest preconditions. Together with their closely related counterparts, Hoare monads, they provide the basis on which verification tools like F*, Hoare Type Theory (HTT), and Ynot are built. We show that Dijkstra monads can be derived "for free" by applying a continuation-passing style (CPS) translation to the standard monadic definitions of the underlying computational effects. Automatically deriving Dijkstra monads in this way provides a correct-by-construction and efficient way of reasoning about user-defined effects in dependent type theories. We demonstrate these ideas in EMF*, a new dependently typed calculus, validating it via both formal proof and a prototype implementation within F*. Besides equipping F* with a more uniform and extensible effect system, EMF* enables a novel mixture of intrinsic and extrinsic proofs within F*.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  note = {Comment: extended pre-print for POPL 2017 final version with the missing ERC acknowledgement},
  file = {/Users/charlielidbury/Zotero/storage/8DDPIJHK/Ahman et al. - 2019 - Dijkstra Monads for Free.pdf;/Users/charlielidbury/Zotero/storage/4N32MFA2/Ahman et al. - 2019 - Dijkstra Monads for Free.html}
}

@inproceedings{altenkirch2010pisigma,
  title = {{{$\Pi\Sigma$}}: {{Dependent}} Types without the Sugar},
  booktitle = {Functional and Logic Programming: 10th International Symposium, {{FLOPS}} 2010, Sendai, Japan, April 19-21, 2010. {{Proceedings}} 10},
  author = {Altenkirch, Thorsten and Danielsson, Nils Anders and L{\"o}h, Andres and Oury, Nicolas},
  year = {2010},
  pages = {40--55},
  publisher = {Springer}
}

@misc{ATSHome,
  title = {{{ATS-Home}}},
  url = {https://www.cs.bu.edu/~hwxi/atslangweb/Home.html},
  urldate = {2024-01-24}
}

@misc{ATSHome,
  title = {{{ATS-Home}}},
  url = {https://www.cs.bu.edu/~hwxi/atslangweb/Home.html},
  urldate = {2024-01-24}
}

@misc{ATSImplements,
  title = {{{ATS-Implements}}},
  url = {https://www.cs.bu.edu/~hwxi/atslangweb/Implements.html},
  urldate = {2024-01-24}
}

@misc{ATSImplements,
  title = {{{ATS-Implements}}},
  url = {https://www.cs.bu.edu/~hwxi/atslangweb/Implements.html},
  urldate = {2024-01-24}
}

@inproceedings{bhargavan2017everest,
  title = {Everest: {{Towards}} a Verified, Drop-in Replacement of {{HTTPS}}},
  booktitle = {2nd Summit on Advances in Programming Languages ({{SNAPL}} 2017)},
  author = {Bhargavan, Karthikeyan and Bond, Barry and {Delignat-Lavaud}, Antoine and Fournet, C{\'e}dric and Hawblitzel, Chris and Hritcu, Catalin and Ishtiaq, Samin and Kohlweiss, Markulf and Leino, Rustan and Lorch, Jay and others},
  year = {2017},
  publisher = {Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik}
}

@inproceedings{chenCombiningProgrammingTheorem2005,
  title = {Combining Programming with Theorem Proving},
  booktitle = {Proceedings of the Tenth {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Chen, Chiyan and Xi, Hongwei},
  year = {2005},
  month = sep,
  series = {{{ICFP}} '05},
  pages = {66--77},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1086365.1086375},
  url = {https://doi.org/10.1145/1086365.1086375},
  urldate = {2024-01-24},
  abstract = {Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming. In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable. To support practical programming, we adopted a design in the past that imposes certain restrictions on the syntactic form of constraints so that some effective means can be found for solving constraints automatically. Evidently, this is a rather em ad hoc design in its nature. In this design, which we claim to be both novel and practical. Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints. In particular, we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving. Also we present some concrete examples in support of the practicality of this design.},
  isbn = {978-1-59593-064-4},
  keywords = {applied type system,ATS,dependent types,proof erasure,theorem proving}
}

@inproceedings{chenCombiningProgrammingTheorem2005,
  title = {Combining Programming with Theorem Proving},
  booktitle = {Proceedings of the Tenth {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Chen, Chiyan and Xi, Hongwei},
  year = {2005},
  month = sep,
  series = {{{ICFP}} '05},
  pages = {66--77},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1086365.1086375},
  url = {https://doi.org/10.1145/1086365.1086375},
  urldate = {2024-01-24},
  abstract = {Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming. In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable. To support practical programming, we adopted a design in the past that imposes certain restrictions on the syntactic form of constraints so that some effective means can be found for solving constraints automatically. Evidently, this is a rather em ad hoc design in its nature. In this design, which we claim to be both novel and practical. Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints. In particular, we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving. Also we present some concrete examples in support of the practicality of this design.},
  isbn = {978-1-59593-064-4},
  keywords = {applied type system,ATS,dependent types,proof erasure,theorem proving}
}

@misc{DijkstraHoareMonads,
  title = {Dijkstra and {{Hoare}} Monads in Monadic Computation - {{ScienceDirect}}},
  url = {https://www.sciencedirect.com/science/article/pii/S0304397515002364},
  urldate = {2024-01-24}
}

@misc{DijkstraHoareMonads,
  title = {Dijkstra and {{Hoare}} Monads in Monadic Computation - {{ScienceDirect}}},
  url = {https://www.sciencedirect.com/science/article/pii/S0304397515002364},
  urldate = {2024-01-24}
}

@misc{DimacsCNFPDF,
  title = {Dimacs {{CNF}} {\textbar} {{PDF}} {\textbar} {{File Format}} {\textbar} {{Areas Of Computer Science}}},
  journal = {Scribd},
  url = {https://www.scribd.com/document/368002947/dimacs-cnf},
  urldate = {2024-01-31},
  abstract = {dimacs spec},
  langid = {english},
  file = {/Users/charlielidbury/Zotero/storage/G9MYXTY3/dimacs-cnf.html}
}

@misc{DimacsCNFPDF,
  title = {Dimacs {{CNF}} {\textbar} {{PDF}} {\textbar} {{File Format}} {\textbar} {{Areas Of Computer Science}}},
  url = {https://www.scribd.com/document/368002947/dimacs-cnf},
  urldate = {2024-01-31},
  abstract = {dimacs spec},
  langid = {english},
  file = {/Users/charlielidbury/Zotero/storage/8TR39UD7/dimacs-cnf.html}
}

@inproceedings{ferraiuolo2017komodo,
  title = {Komodo: {{Using}} Verification to Disentangle Secure-Enclave Hardware from Software},
  booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles},
  author = {Ferraiuolo, Andrew and Baumann, Andrew and Hawblitzel, Chris and Parno, Bryan},
  year = {2017},
  pages = {287--305}
}

@inproceedings{fioraldiAFLCombiningIncremental2020,
  title = {{{AFL}}++: Combining Incremental Steps of Fuzzing Research},
  shorttitle = {{{AFL}}++},
  booktitle = {Proceedings of the 14th {{USENIX Conference}} on {{Offensive Technologies}}},
  author = {Fioraldi, Andrea and Maier, Dominik and Ei{\ss}feldt, Heiko and Heuse, Marc},
  year = {2020},
  month = aug,
  series = {{{WOOT}}'20},
  pages = {10},
  publisher = {USENIX Association},
  address = {USA},
  urldate = {2024-02-02},
  abstract = {In this paper, we present AFL++, a community-driven open-source tool that incorporates state-of-the-art fuzzing research, to make the research comparable, reproducible, combinable and--most importantly - useable. It offers a variety of novel features, for example its Custom Mutator API, able to extend the fuzzing process at many stages. With it, mutators for specific targets can also be written by experienced security testers. We hope for AFL++ to become a new baseline tool not only for current, but also for future research, as it allows to test new techniques quickly, and evaluate not only the effectiveness of the single technique versus the state-of-the-art, but also in combination with other techniques. The paper gives an evaluation of hand-picked fuzzing technologies -- shining light on the fact that while each novel fuzzing method can increase performance in some targets -- it decreases performance for other targets. This is an insight future fuzzing research should consider in their evaluations.},
  file = {/Users/charlielidbury/Zotero/storage/YG8ZD9WS/Fioraldi et al. - 2020 - AFL++ combining incremental steps of fuzzing rese.pdf}
}

@inproceedings{fioraldiAFLCombiningIncremental2020,
  title = {{{AFL}}++: {{Combining}} Incremental Steps of Fuzzing Research},
  shorttitle = {{{AFL}}++},
  booktitle = {Proceedings of the 14th {{USENIX Conference}} on {{Offensive Technologies}}},
  author = {Fioraldi, Andrea and Maier, Dominik and Ei{\ss}feldt, Heiko and Heuse, Marc},
  year = {2020},
  month = aug,
  series = {{{WOOT}}'20},
  pages = {10},
  publisher = {USENIX Association},
  address = {USA},
  urldate = {2024-02-02},
  abstract = {In this paper, we present AFL++, a community-driven open-source tool that incorporates state-of-the-art fuzzing research, to make the research comparable, reproducible, combinable and--most importantly - useable. It offers a variety of novel features, for example its Custom Mutator API, able to extend the fuzzing process at many stages. With it, mutators for specific targets can also be written by experienced security testers. We hope for AFL++ to become a new baseline tool not only for current, but also for future research, as it allows to test new techniques quickly, and evaluate not only the effectiveness of the single technique versus the state-of-the-art, but also in combination with other techniques. The paper gives an evaluation of hand-picked fuzzing technologies -- shining light on the fact that while each novel fuzzing method can increase performance in some targets -- it decreases performance for other targets. This is an insight future fuzzing research should consider in their evaluations.},
  file = {/Users/charlielidbury/Zotero/storage/F4I98C4W/Fioraldi et al. - 2020 - AFL++ combining incremental steps of fuzzing rese.pdf}
}

@inproceedings{groceSwarmTesting2012,
  title = {Swarm Testing},
  booktitle = {Proceedings of the 2012 {{International Symposium}} on {{Software Testing}} and {{Analysis}}},
  author = {Groce, Alex and Zhang, Chaoqiang and Eide, Eric and Chen, Yang and Regehr, John},
  year = {2012},
  month = jul,
  series = {{{ISSTA}} 2012},
  pages = {78--88},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/2338965.2336763},
  url = {https://dl.acm.org/doi/10.1145/2338965.2336763},
  urldate = {2024-01-31},
  abstract = {Swarm testing is a novel and inexpensive way to improve the diversity of test cases generated during random testing. Increased diversity leads to improved coverage and fault detection. In swarm testing, the usual practice of potentially including all features in every test case is abandoned. Rather, a large ``swarm'' of randomly generated configurations, each of which omits some features, is used, with configurations receiving equal resources. We have identified two mechanisms by which feature omission leads to better exploration of a system's state space. First, some features actively prevent the system from executing interesting behaviors; e.g., ``pop'' calls may prevent a stack data structure from executing a bug in its overflow detection logic. Second, even when there is no active suppression of behaviors, test features compete for space in each test, limiting the depth to which logic driven by features can be explored. Experimental results show that swarm testing increases coverage and can improve fault detection dramatically; for example, in a week of testing it found 42\% more distinct ways to crash a collection of C compilers than did the heavily hand-tuned default configuration of a random tester.},
  isbn = {978-1-4503-1454-1},
  file = {/Users/charlielidbury/Zotero/storage/QZ7VU3LE/Groce et al. - 2012 - Swarm testing.pdf}
}

@inproceedings{groceSwarmTesting2012,
  title = {Swarm Testing},
  booktitle = {Proceedings of the 2012 {{International Symposium}} on {{Software Testing}} and {{Analysis}}},
  author = {Groce, Alex and Zhang, Chaoqiang and Eide, Eric and Chen, Yang and Regehr, John},
  year = {2012},
  month = jul,
  series = {{{ISSTA}} 2012},
  pages = {78--88},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/2338965.2336763},
  url = {https://dl.acm.org/doi/10.1145/2338965.2336763},
  urldate = {2024-01-31},
  abstract = {Swarm testing is a novel and inexpensive way to improve the diversity of test cases generated during random testing. Increased diversity leads to improved coverage and fault detection. In swarm testing, the usual practice of potentially including all features in every test case is abandoned. Rather, a large ``swarm'' of randomly generated configurations, each of which omits some features, is used, with configurations receiving equal resources. We have identified two mechanisms by which feature omission leads to better exploration of a system's state space. First, some features actively prevent the system from executing interesting behaviors; e.g., ``pop'' calls may prevent a stack data structure from executing a bug in its overflow detection logic. Second, even when there is no active suppression of behaviors, test features compete for space in each test, limiting the depth to which logic driven by features can be explored. Experimental results show that swarm testing increases coverage and can improve fault detection dramatically; for example, in a week of testing it found 42\% more distinct ways to crash a collection of C compilers than did the heavily hand-tuned default configuration of a random tester.},
  isbn = {978-1-4503-1454-1},
  file = {/Users/charlielidbury/Zotero/storage/4TMWZHCW/Groce et al. - 2012 - Swarm testing.pdf}
}

@misc{HaclstarHaclstar2024,
  title = {Hacl-Star/Hacl-Star},
  year = {2024},
  month = jan,
  url = {https://github.com/hacl-star/hacl-star},
  urldate = {2024-01-25},
  abstract = {HACL*, a formally verified cryptographic library written in F*},
  copyright = {Apache-2.0},
  howpublished = {hacl-star},
  keywords = {cryptography,everest,formal-methods,formal-verification,hacl,high-performance,inria,security,verification,verified-primitives}
}

@misc{HaclstarHaclstar2024,
  title = {Hacl-Star/Hacl-Star},
  year = {2024},
  month = jan,
  url = {https://github.com/hacl-star/hacl-star},
  urldate = {2024-01-25},
  abstract = {HACL*, a formally verified cryptographic library written in F*},
  copyright = {Apache-2.0},
  howpublished = {hacl-star},
  keywords = {cryptography,everest,formal-methods,formal-verification,hacl,high-performance,inria,security,verification,verified-primitives}
}

@misc{IrisProject,
  title = {Iris {{Project}}},
  url = {https://iris-project.org/},
  urldate = {2024-01-25}
}

@misc{IrisProject,
  title = {Iris {{Project}}},
  url = {https://iris-project.org/},
  urldate = {2024-01-25}
}

@article{jacobsDijkstraHoareMonads2015,
  title = {Dijkstra and {{Hoare}} Monads in Monadic Computation},
  author = {Jacobs, Bart},
  year = {2015},
  month = nov,
  journal = {Theoretical Computer Science},
  series = {Coalgebraic {{Methods}} in {{Computer Science}}},
  volume = {604},
  pages = {30--45},
  issn = {0304-3975},
  doi = {10.1016/j.tcs.2015.03.020},
  url = {https://www.sciencedirect.com/science/article/pii/S0304397515002364},
  urldate = {2024-01-24},
  abstract = {The Dijkstra and Hoare monads have been introduced recently for capturing weakest precondition computations and computations with pre- and post-conditions, within the context of program verification, supported by a theorem prover. Here we give a more general description of such monads in a categorical setting. We first elaborate the recently developed view on program semantics in terms of a triangle of computations, state transformers, and predicate transformers. Instantiating this triangle for different computational monads T shows how to define the Dijkstra monad associated with T, via the logic involved. Subsequently we give abstract definitions of the Dijkstra and Hoare monad, parametrised by a computational monad. These definitions presuppose a suitable (categorical) predicate logic, defined on the Kleisli category of the underlying monad. When all this structure exists, we show that there are maps of monads (Hoare) {$\Rightarrow$} (State) {$\Rightarrow$} (Dijkstra), all parametrised by a monad T.},
  keywords = {Hoare logic,Monad,Program semantics,Weakest precondition},
  file = {/Users/charlielidbury/Zotero/storage/3KN8RQJV/Jacobs - 2015 - Dijkstra and Hoare monads in monadic computation.html}
}

@article{jacobsDijkstraHoareMonads2015,
  title = {Dijkstra and {{Hoare}} Monads in Monadic Computation},
  author = {Jacobs, Bart},
  year = {2015},
  month = nov,
  journal = {Theoretical Computer Science},
  series = {Coalgebraic {{Methods}} in {{Computer Science}}},
  volume = {604},
  pages = {30--45},
  issn = {0304-3975},
  doi = {10.1016/j.tcs.2015.03.020},
  url = {https://www.sciencedirect.com/science/article/pii/S0304397515002364},
  urldate = {2024-01-24},
  abstract = {The Dijkstra and Hoare monads have been introduced recently for capturing weakest precondition computations and computations with pre- and post-conditions, within the context of program verification, supported by a theorem prover. Here we give a more general description of such monads in a categorical setting. We first elaborate the recently developed view on program semantics in terms of a triangle of computations, state transformers, and predicate transformers. Instantiating this triangle for different computational monads T shows how to define the Dijkstra monad associated with T, via the logic involved. Subsequently we give abstract definitions of the Dijkstra and Hoare monad, parametrised by a computational monad. These definitions presuppose a suitable (categorical) predicate logic, defined on the Kleisli category of the underlying monad. When all this structure exists, we show that there are maps of monads (Hoare) {$\Rightarrow$} (State) {$\Rightarrow$} (Dijkstra), all parametrised by a monad T.},
  keywords = {Hoare logic,Monad,Program semantics,Weakest precondition},
  file = {/Users/charlielidbury/Zotero/storage/4PNZ73LB/Jacobs - 2015 - Dijkstra and Hoare monads in monadic computation.html}
}

@article{jungRustBeltSecuringFoundations2018,
  title = {{{RustBelt}}: Securing the Foundations of the {{Rust}} Programming Language},
  shorttitle = {{{RustBelt}}},
  author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  year = {2018},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {POPL},
  pages = {1--34},
  issn = {2475-1421},
  doi = {10.1145/3158154},
  url = {https://dl.acm.org/doi/10.1145/3158154},
  urldate = {2024-01-25},
  abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
  langid = {english}
}

@article{jungRustBeltSecuringFoundations2018,
  title = {{{RustBelt}}: {{Securing}} the Foundations of the {{Rust}} Programming Language},
  shorttitle = {{{RustBelt}}},
  author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  year = {2018},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {POPL},
  pages = {1--34},
  issn = {2475-1421},
  doi = {10.1145/3158154},
  url = {https://dl.acm.org/doi/10.1145/3158154},
  urldate = {2024-01-25},
  abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
  langid = {english}
}

@inproceedings{klein2009sel4,
  title = {{{seL4}}: {{Formal}} Verification of an {{OS}} Kernel},
  booktitle = {Proceedings of the {{ACM SIGOPS}} 22nd Symposium on Operating Systems Principles},
  author = {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal and Norrish, Michael and others},
  year = {2009},
  pages = {207--220}
}

@inproceedings{kleinSeL4FormalVerification2009,
  title = {{{seL4}}: Formal Verification of an {{OS}} Kernel},
  shorttitle = {{{seL4}}},
  booktitle = {Proceedings of the {{ACM SIGOPS}} 22nd Symposium on {{Operating}} Systems Principles},
  author = {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal and Norrish, Michael and Sewell, Thomas and Tuch, Harvey and Winwood, Simon},
  year = {2009},
  month = oct,
  pages = {207--220},
  publisher = {ACM},
  address = {Big Sky Montana USA},
  doi = {10.1145/1629575.1629596},
  url = {https://dl.acm.org/doi/10.1145/1629575.1629596},
  urldate = {2024-01-25},
  isbn = {978-1-60558-752-3},
  langid = {english}
}

@inproceedings{kleinSeL4FormalVerification2009,
  title = {{{seL4}}: {{Formal}} Verification of an {{OS}} Kernel},
  shorttitle = {{{seL4}}},
  booktitle = {Proceedings of the {{ACM SIGOPS}} 22nd Symposium on {{Operating}} Systems Principles},
  author = {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal and Norrish, Michael and Sewell, Thomas and Tuch, Harvey and Winwood, Simon},
  year = {2009},
  month = oct,
  pages = {207--220},
  publisher = {ACM},
  address = {Big Sky Montana USA},
  doi = {10.1145/1629575.1629596},
  url = {https://dl.acm.org/doi/10.1145/1629575.1629596},
  urldate = {2024-01-25},
  isbn = {978-1-60558-752-3},
  langid = {english}
}

@inproceedings{lorch2020armada,
  title = {Armada: Low-Effort Verification of High-Performance Concurrent Programs},
  booktitle = {Proceedings of the 41st {{ACM SIGPLAN}} Conference on Programming Language Design and Implementation},
  author = {Lorch, Jacob R and Chen, Yixuan and Kapritsos, Manos and Parno, Bryan and Qadeer, Shaz and Sharma, Upamanyu and Wilcox, James R and Zhao, Xueyuan},
  year = {2020},
  pages = {197--210}
}

@misc{MagmideMagmide2024,
  title = {Magmide/Magmide},
  year = {2024},
  month = jan,
  url = {https://github.com/magmide/magmide},
  urldate = {2024-01-25},
  abstract = {A dependently-typed proof language intended to make provably correct bare metal code possible for working software engineers.},
  howpublished = {magmide},
  keywords = {coq,dependent-types,formal-methods,formal-verification,logic,systems-programming,type-safety,verification}
}

@misc{MagmideMagmide2024,
  title = {Magmide/Magmide},
  year = {2024},
  month = jan,
  url = {https://github.com/magmide/magmide},
  urldate = {2024-01-25},
  abstract = {A dependently-typed proof language intended to make provably correct bare metal code possible for working software engineers.},
  howpublished = {magmide},
  keywords = {coq,dependent-types,formal-methods,formal-verification,logic,systems-programming,type-safety,verification}
}

@inproceedings{nanevskiConsiderationPublicationFunctional,
  title = {Under {{Consideration}} for {{Publication}} in {{J}}. {{Functional Programming Hoare Type Theory}}, {{Polymorphism}} and {{Separation}}},
  author = {Nanevski, Aleksandar and Morrisett, Greg and Birkedal, L.},
  url = {https://www.semanticscholar.org/paper/Under-Consideration-for-Publication-in-J.-Hoare-and-Nanevski-Morrisett/aef3d1fc100d0ed4561549da30f002bf9ee21722},
  urldate = {2024-01-24},
  abstract = {We consider the problem of reconciling a dependently typed functional language with imperative features such as mutable higher-order state, pointer aliasing, and non-termination. We propose Hoare Type Theory (HTT), which incorporates Hoare-style specifications into types, making it possible to statically track and enforce correct use of side effects. The main feature of HTT is the Hoare type \{P \}x:A\{Q\} specifying computations with precondition P and postcondition Q that return a result of type A. Hoare types can be nested, combined with other types, and abstracted, leading to a smooth integration with higher-order functions and type polymorphism. We further show that in the presence of type polymorphism, it becomes possible to interpret the Hoare types in the " small footprint " manner, as advocated by Separation Logic, whereby specifications tightly describe the state required by the computation. We establish that HTT is sound and compositional, in the sense that separate verifica-tions of individual program components suffice to ensure the correctness of the composite program.},
  note = {[TLDR] This work considers the problem of reconciling a dependently typed functional language with imperative features such as mutable higher-order state, pointer aliasing, and non-termination, and proposes Hoare Type Theory (HTT), which incorporates Hoare-style specifications into types, making it possible to statically track and enforce correct use of side effects.}
}

@inproceedings{nanevskiConsiderationPublicationFunctional,
  title = {Under {{Consideration}} for {{Publication}} in {{J}}. {{Functional Programming Hoare Type Theory}}, {{Polymorphism}} and {{Separation}}},
  author = {Nanevski, Aleksandar and Morrisett, Greg and Birkedal, L.},
  url = {https://www.semanticscholar.org/paper/Under-Consideration-for-Publication-in-J.-Hoare-and-Nanevski-Morrisett/aef3d1fc100d0ed4561549da30f002bf9ee21722},
  urldate = {2024-01-24},
  abstract = {We consider the problem of reconciling a dependently typed functional language with imperative features such as mutable higher-order state, pointer aliasing, and non-termination. We propose Hoare Type Theory (HTT), which incorporates Hoare-style specifications into types, making it possible to statically track and enforce correct use of side effects. The main feature of HTT is the Hoare type \{P \}x:A\{Q\} specifying computations with precondition P and postcondition Q that return a result of type A. Hoare types can be nested, combined with other types, and abstracted, leading to a smooth integration with higher-order functions and type polymorphism. We further show that in the presence of type polymorphism, it becomes possible to interpret the Hoare types in the " small footprint " manner, as advocated by Separation Logic, whereby specifications tightly describe the state required by the computation. We establish that HTT is sound and compositional, in the sense that separate verifica-tions of individual program components suffice to ensure the correctness of the composite program.},
  note = {[TLDR] This work considers the problem of reconciling a dependently typed functional language with imperative features such as mutable higher-order state, pointer aliasing, and non-termination, and proposes Hoare Type Theory (HTT), which incorporates Hoare-style specifications into types, making it possible to statically track and enforce correct use of side effects.}
}

@article{nanevskiYnotDependentTypes2008,
  title = {Ynot: Dependent Types for Imperative Programs},
  shorttitle = {Ynot},
  author = {Nanevski, Aleksandar and Morrisett, Greg and Shinnar, Avraham and Govereau, Paul and Birkedal, Lars},
  year = {2008},
  month = sep,
  journal = {ACM SIGPLAN Notices},
  volume = {43},
  number = {9},
  pages = {229--240},
  issn = {0362-1340},
  doi = {10.1145/1411203.1411237},
  url = {https://doi.org/10.1145/1411203.1411237},
  urldate = {2024-01-24},
  abstract = {We describe an axiomatic extension to the Coq proof assistant, that supports writing, reasoning about, and extracting higher-order, dependently-typed programs with side-effects. Coq already includes a powerful functional language that supports dependent types, but that language is limited to pure, total functions. The key contribution of our extension, which we call Ynot, is the added support for computations that may have effects such as non-termination, accessing a mutable store, and throwing/catching exceptions. The axioms of Ynot form a small trusted computing base which has been formally justified in our previous work on Hoare Type Theory (HTT). We show how these axioms can be combined with the powerful type and abstraction mechanisms of Coq to build higher-level reasoning mechanisms which in turn can be used to build realistic, verified software components. To substantiate this claim, we describe here a representative series of modules that implement imperative finite maps, including support for a higher-order (effectful) iterator. The implementations range from simple (e.g., association lists) to complex (e.g., hash tables) but share a common interface which abstracts the implementation details and ensures that the modules properly implement the finite map abstraction.},
  keywords = {Hoare logic,monads,separation logic,type theory}
}

@article{nanevskiYnotDependentTypes2008,
  title = {Ynot: {{Dependent}} Types for Imperative Programs},
  shorttitle = {Ynot},
  author = {Nanevski, Aleksandar and Morrisett, Greg and Shinnar, Avraham and Govereau, Paul and Birkedal, Lars},
  year = {2008},
  month = sep,
  journal = {ACM SIGPLAN Notices},
  volume = {43},
  number = {9},
  pages = {229--240},
  issn = {0362-1340},
  doi = {10.1145/1411203.1411237},
  url = {https://doi.org/10.1145/1411203.1411237},
  urldate = {2024-01-24},
  abstract = {We describe an axiomatic extension to the Coq proof assistant, that supports writing, reasoning about, and extracting higher-order, dependently-typed programs with side-effects. Coq already includes a powerful functional language that supports dependent types, but that language is limited to pure, total functions. The key contribution of our extension, which we call Ynot, is the added support for computations that may have effects such as non-termination, accessing a mutable store, and throwing/catching exceptions. The axioms of Ynot form a small trusted computing base which has been formally justified in our previous work on Hoare Type Theory (HTT). We show how these axioms can be combined with the powerful type and abstraction mechanisms of Coq to build higher-level reasoning mechanisms which in turn can be used to build realistic, verified software components. To substantiate this claim, we describe here a representative series of modules that implement imperative finite maps, including support for a higher-order (effectful) iterator. The implementations range from simple (e.g., association lists) to complex (e.g., hash tables) but share a common interface which abstracts the implementation details and ensures that the modules properly implement the finite map abstraction.},
  keywords = {Hoare logic,monads,separation logic,type theory}
}

@article{pierre-evaristeTransportingFunctionsOrnaments2014,
  title = {Transporting {{Functions}} across {{Ornaments}}},
  author = {{Pierre-Evariste}, Dagand and Conor, McBride},
  year = {2014},
  month = may,
  journal = {Journal of Functional Programming},
  volume = {24},
  number = {2-3},
  eprint = {1201.4801},
  primaryclass = {cs},
  pages = {316--383},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796814000069},
  url = {http://arxiv.org/abs/1201.4801},
  urldate = {2024-01-24},
  abstract = {Programming with dependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the definition of data-types: we can finally write correct-by-construction software. However, this extreme accuracy is also a curse: a data-type is the combination of a structuring medium together with a special purpose logic. These domain-specific logics hamper any effort of code reuse among similarly structured data. In this paper, we exorcise our data-types by adapting the notion of ornament to our universe of inductive families. We then show how code reuse can be achieved by ornamenting functions. Using these functional ornament, we capture the relationship between functions such as the addition of natural numbers and the concatenation of lists. With this knowledge, we demonstrate how the implementation of the former informs the implementation of the latter: the user can ask the definition of addition to be lifted to lists and she will only be asked the details necessary to carry on adding lists rather than numbers. Our presentation is formalised in a type theory with a universe of data-types and all our constructions have been implemented as generic programs, requiring no extension to the type theory.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/R2829K92/Pierre-Evariste and Conor - 2014 - Transporting Functions across Ornaments.pdf;/Users/charlielidbury/Zotero/storage/HC3TCW8I/Pierre-Evariste and Conor - 2014 - Transporting Functions across Ornaments.html}
}

@article{pierre-evaristeTransportingFunctionsOrnaments2014,
  title = {Transporting {{Functions}} across {{Ornaments}}},
  author = {{Pierre-Evariste}, Dagand and Conor, McBride},
  year = {2014},
  month = may,
  journal = {Journal of Functional Programming},
  volume = {24},
  number = {2-3},
  eprint = {1201.4801},
  primaryclass = {cs},
  pages = {316--383},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796814000069},
  url = {http://arxiv.org/abs/1201.4801},
  urldate = {2024-01-24},
  abstract = {Programming with dependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the definition of data-types: we can finally write correct-by-construction software. However, this extreme accuracy is also a curse: a data-type is the combination of a structuring medium together with a special purpose logic. These domain-specific logics hamper any effort of code reuse among similarly structured data. In this paper, we exorcise our data-types by adapting the notion of ornament to our universe of inductive families. We then show how code reuse can be achieved by ornamenting functions. Using these functional ornament, we capture the relationship between functions such as the addition of natural numbers and the concatenation of lists. With this knowledge, we demonstrate how the implementation of the former informs the implementation of the latter: the user can ask the definition of addition to be lifted to lists and she will only be asked the details necessary to carry on adding lists rather than numbers. Our presentation is formalised in a type theory with a universe of data-types and all our constructions have been implemented as generic programs, requiring no extension to the type theory.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/IGPDEUYJ/Pierre-Evariste and Conor - 2014 - Transporting Functions across Ornaments.pdf;/Users/charlielidbury/Zotero/storage/BPFQ54M3/Pierre-Evariste and Conor - 2014 - Transporting Functions across Ornaments.html}
}

@article{protzenkoLowVerifiedLowLevel2017,
  title = {Low*:  {{Verified Low-Level Programming Embedded}} in {{F}}*},
  author = {Protzenko, Jonathan and Zinzindohou{\'e}, Jean-Karim and Rastogi, Aseem and Ramananandro, Tahina and Wang, Peng and {Zanella-B{\'e}guelin}, Santiago and {Delignat-Lavaud}, Antoine and Hritcu, Catalin and Bhargavan, Karthikeyan and Fournet, C{\'e}dric and Swamy, Nikhil},
  year = {2017},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {1},
  number = {ICFP},
  eprint = {1703.00053},
  primaryclass = {cs},
  pages = {1--29},
  issn = {2475-1421},
  doi = {10.1145/3110261},
  url = {http://arxiv.org/abs/1703.00053},
  urldate = {2024-01-24},
  abstract = {We present Low*, a language for low-level programming and verification, and its application to high-assurance optimized cryptographic libraries. Low* is a shallow embedding of a small, sequential, well-behaved subset of C in F*, a dependently-typed variant of ML aimed at program verification. Departing from ML, Low* does not involve any garbage collection or implicit heap allocation; instead, it has a structured memory model {\textbackslash}`a la CompCert, and it provides the control required for writing efficient low-level security-critical code. By virtue of typing, any Low* program is memory safe. In addition, the programmer can make full use of the verification power of F* to write high-level specifications and verify the functional correctness of Low* code using a combination of SMT automation and sophisticated manual proofs. At extraction time, specifications and proofs are erased, and the remaining code enjoys a predictable translation to C. We prove that this translation preserves semantics and side-channel resistance. We provide a new compiler back-end from Low* to C and, to evaluate our approach, we implement and verify various cryptographic algorithms, constructions, and tools for a total of about 28,000 lines of code, specification and proof. We show that our Low* code delivers performance competitive with existing (unverified) C cryptographic libraries, suggesting our approach may be applicable to larger-scale low-level software.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Programming Languages},
  note = {Comment: extended version of ICFP final camera ready version; only Acknowledgements differ from 30 Aug 2017 version},
  file = {/Users/charlielidbury/Zotero/storage/6DNMIKF6/Protzenko et al. - 2017 - Verified Low-Level Programming Embedded in F.pdf;/Users/charlielidbury/Zotero/storage/UTTHN35Q/Protzenko et al. - 2017 - Verified Low-Level Programming Embedded in F.html}
}

@article{protzenkoLowVerifiedLowLevel2017,
  title = {Low*: {{Verified Low-Level Programming Embedded}} in {{F}}*},
  author = {Protzenko, Jonathan and Zinzindohou{\'e}, Jean-Karim and Rastogi, Aseem and Ramananandro, Tahina and Wang, Peng and {Zanella-B{\'e}guelin}, Santiago and {Delignat-Lavaud}, Antoine and Hritcu, Catalin and Bhargavan, Karthikeyan and Fournet, C{\'e}dric and Swamy, Nikhil},
  year = {2017},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {1},
  number = {ICFP},
  eprint = {1703.00053},
  primaryclass = {cs},
  pages = {1--29},
  issn = {2475-1421},
  doi = {10.1145/3110261},
  url = {http://arxiv.org/abs/1703.00053},
  urldate = {2024-01-24},
  abstract = {We present Low*, a language for low-level programming and verification, and its application to high-assurance optimized cryptographic libraries. Low* is a shallow embedding of a small, sequential, well-behaved subset of C in F*, a dependently-typed variant of ML aimed at program verification. Departing from ML, Low* does not involve any garbage collection or implicit heap allocation; instead, it has a structured memory model {\textbackslash}`a la CompCert, and it provides the control required for writing efficient low-level security-critical code. By virtue of typing, any Low* program is memory safe. In addition, the programmer can make full use of the verification power of F* to write high-level specifications and verify the functional correctness of Low* code using a combination of SMT automation and sophisticated manual proofs. At extraction time, specifications and proofs are erased, and the remaining code enjoys a predictable translation to C. We prove that this translation preserves semantics and side-channel resistance. We provide a new compiler back-end from Low* to C and, to evaluate our approach, we implement and verify various cryptographic algorithms, constructions, and tools for a total of about 28,000 lines of code, specification and proof. We show that our Low* code delivers performance competitive with existing (unverified) C cryptographic libraries, suggesting our approach may be applicable to larger-scale low-level software.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Programming Languages},
  note = {Comment: extended version of ICFP final camera ready version; only Acknowledgements differ from 30 Aug 2017 version},
  file = {/Users/charlielidbury/Zotero/storage/ANFFDPCU/Protzenko et al. - 2017 - Verified Low-Level Programming Embedded in F.pdf;/Users/charlielidbury/Zotero/storage/2WRN5JKJ/Protzenko et al. - 2017 - Verified Low-Level Programming Embedded in F.html}
}

@misc{rust-anecdote,
  author = {Hoare, Graydon},
  year = {2022},
  month = feb,
  url = {https://twitter.com/graydon_pub/status/1492792051657629698}
}

@misc{RustProgrammingLanguage,
  title = {Rust {{Programming Language}}},
  url = {https://www.rust-lang.org/},
  urldate = {2024-06-04}
}

@misc{stackoverflow,
  title = {{{StackOverflow}} Developer Survey},
  year = {2021},
  url = {https://insights.stackoverflow.com/survey/2021}
}

@inproceedings{swamyVerifyingHigherorderPrograms2013,
  title = {Verifying {{Higher-order Programs}} with the {{Dijkstra Monad}}},
  booktitle = {{{ACM Programming Language Design}} and {{Implementation}} ({{PLDI}}) 2013},
  author = {Swamy, Nikhil and Chen, Juan and Livshits, Ben},
  year = {2013},
  month = jun,
  url = {https://www.microsoft.com/en-us/research/publication/verifying-higher-order-programs-with-the-dijkstra-monad/},
  urldate = {2024-01-24},
  abstract = {Modern programming languages, ranging from Haskell and ML, to JavaScript, C\# and Java, all make extensive use of higher-order state. This paper advocates a new verification methodology for higher-order stateful programs, based on a new monad of predicate transformers called the Dijkstra monad. Using the Dijkstra monad has a number of benefits. First, the monad [{\dots}]},
  langid = {american},
  file = {/Users/charlielidbury/Zotero/storage/E46BW5N8/Swamy et al. - 2013 - Verifying Higher-order Programs with the Dijkstra .pdf}
}

@inproceedings{swamyVerifyingHigherorderPrograms2013,
  title = {Verifying {{Higher-order Programs}} with the {{Dijkstra Monad}}},
  booktitle = {{{ACM Programming Language Design}} and {{Implementation}} ({{PLDI}}) 2013},
  author = {Swamy, Nikhil and Chen, Juan and Livshits, Ben},
  year = {2013},
  month = jun,
  url = {https://www.microsoft.com/en-us/research/publication/verifying-higher-order-programs-with-the-dijkstra-monad/},
  urldate = {2024-01-24},
  abstract = {Modern programming languages, ranging from Haskell and ML, to JavaScript, C\# and Java, all make extensive use of higher-order state. This paper advocates a new verification methodology for higher-order stateful programs, based on a new monad of predicate transformers called the Dijkstra monad. Using the Dijkstra monad has a number of benefits. First, the monad [{\dots}]},
  langid = {american},
  file = {/Users/charlielidbury/Zotero/storage/GKE9R2ET/Swamy et al. - 2013 - Verifying Higher-order Programs with the Dijkstra .pdf}
}

@misc{ullrichElectrolysisCoverage,
  title = {Electrolysis {{Coverage}}},
  author = {Ullrich, Sebastian},
  url = {https://kha.github.io/electrolysis/},
  urldate = {2024-01-25},
  file = {/Users/charlielidbury/Zotero/storage/BCYWRSI2/electrolysis.html}
}

@misc{ullrichElectrolysisCoverage,
  title = {Electrolysis {{Coverage}}},
  author = {Ullrich, Sebastian},
  url = {https://kha.github.io/electrolysis/},
  urldate = {2024-01-25},
  file = {/Users/charlielidbury/Zotero/storage/G39LBKD2/electrolysis.html}
}

@misc{ullrichKhaElectrolysis2024,
  title = {Kha/Electrolysis},
  author = {Ullrich, Sebastian},
  year = {2024},
  month = jan,
  url = {https://github.com/Kha/electrolysis},
  urldate = {2024-01-24},
  abstract = {Simple verification of Rust programs via functional purification in Lean 2(!)}
}

@misc{ullrichKhaElectrolysis2024,
  title = {Kha/Electrolysis},
  author = {Ullrich, Sebastian},
  year = {2024},
  month = jan,
  url = {https://github.com/Kha/electrolysis},
  urldate = {2024-01-24},
  abstract = {Simple verification of Rust programs via functional purification in Lean 2(!)}
}

@misc{VerifiedEfficientParsing,
  title = {Verified Efficient Parsing for Binary Data Formats --- {{EverParse Manual}} Documentation},
  url = {https://project-everest.github.io/everparse/},
  urldate = {2024-01-25},
  file = {/Users/charlielidbury/Zotero/storage/9ITH4RI8/everparse.html}
}

@misc{VerifiedEfficientParsing,
  title = {Verified Efficient Parsing for Binary Data Formats --- {{EverParse Manual}} Documentation},
  url = {https://project-everest.github.io/everparse/},
  urldate = {2024-01-25},
  file = {/Users/charlielidbury/Zotero/storage/GLISABPI/everparse.html}
}

@misc{xiAppliedTypeSystem2017,
  title = {Applied {{Type System}}: {{An Approach}} to {{Practical Programming}} with {{Theorem-Proving}}},
  shorttitle = {Applied {{Type System}}},
  author = {Xi, Hongwei},
  year = {2017},
  month = mar,
  number = {arXiv:1703.08683},
  eprint = {1703.08683},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1703.08683},
  url = {http://arxiv.org/abs/1703.08683},
  urldate = {2024-01-24},
  abstract = {The framework Pure Type System (PTS) offers a simple and general approach to designing and formalizing type systems. However, in the presence of dependent types, there often exist certain acute problems that make it difficult for PTS to directly accommodate many common realistic programming features such as general recursion, recursive types, effects (e.g., exceptions, references, input/output), etc. In this paper, Applied Type System (ATS) is presented as a framework for designing and formalizing type systems in support of practical programming with advanced types (including dependent types). In particular, it is demonstrated that ATS can readily accommodate a paradigm referred to as programming with theorem-proving (PwTP) in which programs and proofs are constructed in a syntactically intertwined manner, yielding a practical approach to internalizing constraint-solving needed during type-checking. The key salient feature of ATS lies in a complete separation between statics, where types are formed and reasoned about, and dynamics, where programs are constructed and evaluated. With this separation, it is no longer possible for a program to occur in a type as is otherwise allowed in PTS. The paper contains not only a formal development of ATS but also some examples taken from ats-lang.org, a programming language with a type system rooted in ATS, in support of employing ATS as a framework to formulate advanced type systems for practical programming.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/AX5D88SU/Xi - 2017 - Applied Type System An Approach to Practical Prog.pdf;/Users/charlielidbury/Zotero/storage/AVQ38G85/Xi - 2017 - Applied Type System An Approach to Practical Prog.html}
}

@misc{xiAppliedTypeSystem2017,
  title = {Applied {{Type System}}: {{An Approach}} to {{Practical Programming}} with {{Theorem-Proving}}},
  shorttitle = {Applied {{Type System}}},
  author = {Xi, Hongwei},
  year = {2017},
  month = mar,
  number = {arXiv:1703.08683},
  eprint = {1703.08683},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1703.08683},
  url = {http://arxiv.org/abs/1703.08683},
  urldate = {2024-01-24},
  abstract = {The framework Pure Type System (PTS) offers a simple and general approach to designing and formalizing type systems. However, in the presence of dependent types, there often exist certain acute problems that make it difficult for PTS to directly accommodate many common realistic programming features such as general recursion, recursive types, effects (e.g., exceptions, references, input/output), etc. In this paper, Applied Type System (ATS) is presented as a framework for designing and formalizing type systems in support of practical programming with advanced types (including dependent types). In particular, it is demonstrated that ATS can readily accommodate a paradigm referred to as programming with theorem-proving (PwTP) in which programs and proofs are constructed in a syntactically intertwined manner, yielding a practical approach to internalizing constraint-solving needed during type-checking. The key salient feature of ATS lies in a complete separation between statics, where types are formed and reasoned about, and dynamics, where programs are constructed and evaluated. With this separation, it is no longer possible for a program to occur in a type as is otherwise allowed in PTS. The paper contains not only a formal development of ATS but also some examples taken from ats-lang.org, a programming language with a type system rooted in ATS, in support of employing ATS as a framework to formulate advanced type systems for practical programming.},
  archiveprefix = {arxiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/Users/charlielidbury/Zotero/storage/7QXFF65Y/Xi - 2017 - Applied Type System An Approach to Practical Prog.pdf;/Users/charlielidbury/Zotero/storage/A85LQM2C/Xi - 2017 - Applied Type System An Approach to Practical Prog.html}
}

@inproceedings{xiImperativeProgrammingDependent2000,
  title = {Imperative Programming with Dependent Types},
  booktitle = {Proceedings {{Fifteenth Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{Cat}}. {{No}}.{{99CB36332}})},
  author = {Xi, Hongwei},
  year = {2000},
  month = jun,
  pages = {375--387},
  issn = {1043-6871},
  doi = {10.1109/LICS.2000.855785},
  url = {https://ieeexplore.ieee.org/document/855785},
  urldate = {2024-01-24},
  abstract = {The article enriches imperative programming with a form of dependent types. We start by explaining some motivations for this enrichment and mentioning some major obstacles that need to be overcome. We then present the design of a source level dependently typed imperative programming language Xanadu, forming both static and dynamic semantics and then establishing the type soundness theorem. We also present realistic examples, which have all been verified in a prototype implementation, in support of the practicality of Xanadu. We claim that the language design of Xanadu is novel and it serves as an informative example that demonstrates a means to combine imperative programming with dependent types.},
  keywords = {Assembly,Computer languages,Dynamic programming,Functional programming,Natural languages,Pattern matching,Programming profession,Proposals,Prototypes,Runtime},
  file = {/Users/charlielidbury/Zotero/storage/EBV2WRZB/Xi - 2000 - Imperative programming with dependent types.html}
}

@inproceedings{xiImperativeProgrammingDependent2000,
  title = {Imperative Programming with Dependent Types},
  booktitle = {Proceedings {{Fifteenth Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{Cat}}. {{No}}.{{99CB36332}})},
  author = {Xi, Hongwei},
  year = {2000},
  month = jun,
  pages = {375--387},
  issn = {1043-6871},
  doi = {10.1109/LICS.2000.855785},
  url = {https://ieeexplore.ieee.org/document/855785},
  urldate = {2024-01-24},
  abstract = {The article enriches imperative programming with a form of dependent types. We start by explaining some motivations for this enrichment and mentioning some major obstacles that need to be overcome. We then present the design of a source level dependently typed imperative programming language Xanadu, forming both static and dynamic semantics and then establishing the type soundness theorem. We also present realistic examples, which have all been verified in a prototype implementation, in support of the practicality of Xanadu. We claim that the language design of Xanadu is novel and it serves as an informative example that demonstrates a means to combine imperative programming with dependent types.},
  keywords = {Assembly,Computer languages,Dynamic programming,Functional programming,Natural languages,Pattern matching,Programming profession,Proposals,Prototypes,Runtime},
  file = {/Users/charlielidbury/Zotero/storage/PC4XYNPP/Xi - 2000 - Imperative programming with dependent types.html}
}

@misc{zalewskiTechnicalWhitepaperAflfuzz2016,
  title = {Technical "Whitepaper" for Afl-Fuzz},
  author = {Zalewski, Micha{\l}},
  year = {2016},
  url = {https://lcamtuf.coredump.cx/afl/technical_details.txt},
  urldate = {2024-01-31},
  file = {/Users/charlielidbury/Zotero/storage/99KAJ4D6/technical_details.html}
}

@misc{zalewskiTechnicalWhitepaperAflfuzz2016,
  title = {Technical "Whitepaper" for Afl-Fuzz},
  author = {Zalewski, Micha{\l}},
  year = {2016},
  url = {https://lcamtuf.coredump.cx/afl/technical_details.txt},
  urldate = {2024-01-31},
  file = {/Users/charlielidbury/Zotero/storage/SITQ3X8K/technical_details.html}
}
